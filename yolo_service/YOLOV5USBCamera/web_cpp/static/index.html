<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YOLO ç‰©ä½“è¯†åˆ« & äººè„¸æƒ…æ„Ÿè¯†åˆ«ç³»ç»Ÿ</title>
    <link rel="stylesheet" href="/static/style.css">
</head>
<body>
    <div class="container">
        <header>
            <h1 id="system-title">ğŸ¯ YOLO USB æ‘„åƒå¤´å®æ—¶æ£€æµ‹ç³»ç»Ÿ</h1>
            <div class="model-switch">
                <button id="detection-btn" class="btn btn-primary model-btn active" onclick="switchModel('detection')">
                    ğŸ¯ ç‰©ä½“è¯†åˆ«
                </button>
                <button id="emotion-btn" class="btn btn-secondary model-btn" onclick="switchModel('emotion')">
                    ğŸ˜Š äººè„¸æƒ…æ„Ÿè¯†åˆ«
                </button>
            </div>
            <div class="status-bar">
                <span id="fps-display">FPS: 0</span>
                <span id="detection-count">æ£€æµ‹æ•°: 0</span>
                <span id="status-display">çŠ¶æ€: æœªè¿æ¥</span>
            </div>
        </header>

        <main>
            <div class="video-container">
                <div class="canvas-wrapper">
                    <canvas id="video-canvas"></canvas>
                    <canvas id="detection-canvas"></canvas>
                </div>
                <div class="no-video" id="no-video-message">
                    <p>ğŸ“· ç­‰å¾…è§†é¢‘æµ...</p>
                </div>
            </div>

            <div class="controls">
                <button id="start-btn" class="btn btn-primary">â–¶ï¸ å¼€å§‹æ£€æµ‹</button>
                <button id="stop-btn" class="btn btn-danger" disabled>â¹ï¸ åœæ­¢æ£€æµ‹</button>
                <button id="refresh-btn" class="btn btn-secondary">ğŸ”„ åˆ·æ–°</button>
            </div>

            <div class="settings">
                <h3>âš™ï¸ æ£€æµ‹è®¾ç½®</h3>
                <div class="setting-item">
                    <label for="confidence-threshold">ç½®ä¿¡åº¦é˜ˆå€¼:</label>
                    <input type="range" id="confidence-threshold" min="0" max="1" step="0.05" value="0.7">
                    <span id="confidence-value">0.70</span>
                </div>
                <div class="setting-item">
                    <label for="nms-threshold">NMS é˜ˆå€¼:</label>
                    <input type="range" id="nms-threshold" min="0" max="1" step="0.05" value="0.45">
                    <span id="nms-value">0.45</span>
                </div>
                <div class="setting-item">
                    <label for="max-fps">æœ€å¤§ FPS:</label>
                    <input type="range" id="max-fps" min="1" max="30" step="1" value="15">
                    <span id="fps-value">15</span>
                </div>
                <button id="apply-settings" class="btn btn-secondary">åº”ç”¨è®¾ç½®</button>
            </div>

            <div class="detection-list">
                <h3>ğŸ“Š æ£€æµ‹ç»“æœ</h3>
                <div id="detection-results">
                    <p class="no-detections">æš‚æ— æ£€æµ‹ç»“æœ</p>
                </div>
            </div>

            <div class="statistics">
                <h3>ğŸ“ˆ ç»Ÿè®¡ä¿¡æ¯</h3>
                <div id="stats-container">
                    <div class="stat-item">
                        <span class="stat-label">è¿è¡Œæ—¶é—´:</span>
                        <span id="runtime" class="stat-value">0 ç§’</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">æ€»å¸§æ•°:</span>
                        <span id="total-frames" class="stat-value">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">æ€»æ£€æµ‹æ•°:</span>
                        <span id="total-detections" class="stat-value">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">å¹³å‡æ£€æµ‹/å¸§:</span>
                        <span id="avg-detections" class="stat-value">0.00</span>
                    </div>
                </div>
            </div>
        </main>

        <footer>
            <p>YOLO v5 USB Camera Detection System | Powered by FastAPI & WebSocket</p>
        </footer>
    </div>

    <script>
        // å…¨å±€å˜é‡
        let ws = null;
        let isRunning = false;
        let statsInterval = null;

        // Canvas å…ƒç´ 
        const videoCanvas = document.getElementById('video-canvas');
        const detectionCanvas = document.getElementById('detection-canvas');
        const videoCtx = videoCanvas.getContext('2d');
        const detectionCtx = detectionCanvas.getContext('2d');

        // æ§åˆ¶æŒ‰é’®
        const startBtn = document.getElementById('start-btn');
        const stopBtn = document.getElementById('stop-btn');
        const refreshBtn = document.getElementById('refresh-btn');
        const applySettingsBtn = document.getElementById('apply-settings');

        // é…ç½®æ»‘å—
        const confidenceSlider = document.getElementById('confidence-threshold');
        const nmsSlider = document.getElementById('nms-threshold');
        const fpsSlider = document.getElementById('max-fps');

        // é¢œè‰²æ˜ å°„
        const classColors = {
            // äººè„¸æ£€æµ‹ç±»åˆ«
            'person': '#FF0000',
            'car': '#00FF00',
            'truck': '#0000FF',
            'bicycle': '#FFFF00',
            'motorbike': '#FF00FF',
            'bus': '#00FFFF',
            'traffic light': '#FF8000',
            'stop sign': '#8000FF',
            // æƒ…æ„Ÿè¯†åˆ«ç±»åˆ«
            'Surprise': '#FF6B6B',
            'Fear': '#4ECDC4',
            'Disgust': '#45B7D1',
            'Happy': '#96CEB4',
            'Sad': '#FFEAA7',
            'Anger': '#DDA0DD',
            'Neutral': '#D3D3D3',
            'default': '#FFFFFF'
        };

        // WebSocket è¿æ¥
        function connectWebSocket() {
            const wsUrl = `ws://${window.location.host}/ws`;
            ws = new WebSocket(wsUrl);

            ws.onopen = () => {
                console.log('WebSocket è¿æ¥å·²å»ºç«‹');
                updateStatus('å·²è¿æ¥', 'connected');
            };

            ws.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    handleDetectionData(data);
                } catch (error) {
                    console.error('è§£ææ•°æ®å¤±è´¥:', error);
                }
            };

            ws.onerror = (error) => {
                console.error('WebSocket é”™è¯¯:', error);
                updateStatus('è¿æ¥é”™è¯¯', 'error');
            };

            ws.onclose = () => {
                console.log('WebSocket è¿æ¥å·²å…³é—­');
                updateStatus('æœªè¿æ¥', 'disconnected');
                ws = null;
            };
        }

        // å¤„ç†æ£€æµ‹æ•°æ®
        function handleDetectionData(data) {
            // æ›´æ–°è§†é¢‘å¸§
            if (data.frame) {
                displayFrame(data.frame);
            }

            // ç»˜åˆ¶æ£€æµ‹æ¡†
            if (data.detections) {
                drawDetections(data.detections);
                updateDetectionList(data.detections);
            }

            // æ›´æ–° FPS å’Œç»Ÿè®¡
            if (data.fps !== undefined) {
                document.getElementById('fps-display').textContent = `FPS: ${data.fps}`;
            }
            if (data.detections) {
                document.getElementById('detection-count').textContent = `æ£€æµ‹æ•°: ${data.detections.length}`;
            }
        }

        // æ˜¾ç¤ºè§†é¢‘å¸§
        function displayFrame(frameBase64) {
            const img = new Image();
            img.onload = function() {
                // è®¾ç½® canvas å¤§å°
                if (videoCanvas.width !== img.width || videoCanvas.height !== img.height) {
                    videoCanvas.width = img.width;
                    videoCanvas.height = img.height;
                    detectionCanvas.width = img.width;
                    detectionCanvas.height = img.height;
                }

                // ç»˜åˆ¶å›¾åƒ
                videoCtx.drawImage(img, 0, 0);

                // éšè—æ— è§†é¢‘æ¶ˆæ¯
                document.getElementById('no-video-message').style.display = 'none';
            };
            img.src = 'data:image/jpeg;base64,' + frameBase64;
        }

        // ç»˜åˆ¶æ£€æµ‹æ¡†
        function drawDetections(detections) {
            // æ¸…é™¤ä¹‹å‰çš„æ£€æµ‹æ¡†
            detectionCtx.clearRect(0, 0, detectionCanvas.width, detectionCanvas.height);

            detections.forEach(detection => {
                const bbox = detection.bbox;
                const color = classColors[detection.class] || classColors['default'];

                // ç»˜åˆ¶è¾¹ç•Œæ¡†
                detectionCtx.strokeStyle = color;
                detectionCtx.lineWidth = 2;
                detectionCtx.strokeRect(bbox.x, bbox.y, bbox.width, bbox.height);

                // ç»˜åˆ¶æ ‡ç­¾èƒŒæ™¯
                const label = `${detection.class}: ${detection.confidence.toFixed(2)}`;
                detectionCtx.font = '14px Arial';
                const textMetrics = detectionCtx.measureText(label);
                const textHeight = 16;

                detectionCtx.fillStyle = color;
                detectionCtx.fillRect(
                    bbox.x,
                    bbox.y - textHeight - 4,
                    textMetrics.width + 8,
                    textHeight + 4
                );

                // ç»˜åˆ¶æ ‡ç­¾æ–‡æœ¬
                detectionCtx.fillStyle = 'white';
                detectionCtx.fillText(label, bbox.x + 4, bbox.y - 4);
            });
        }

        // æ›´æ–°æ£€æµ‹åˆ—è¡¨
        function updateDetectionList(detections) {
            const container = document.getElementById('detection-results');

            if (detections.length === 0) {
                container.innerHTML = '<p class="no-detections">æš‚æ— æ£€æµ‹ç»“æœ</p>';
                return;
            }

            // ç»Ÿè®¡å„ç±»åˆ«æ•°é‡
            const counts = {};
            detections.forEach(d => {
                counts[d.class] = (counts[d.class] || 0) + 1;
            });

            // ç”Ÿæˆåˆ—è¡¨ HTML
            let html = '<ul class="detection-items">';
            for (const [className, count] of Object.entries(counts)) {
                const color = classColors[className] || classColors['default'];
                html += `
                    <li class="detection-item">
                        <span class="detection-color" style="background-color: ${color}"></span>
                        <span class="detection-class">${className}</span>
                        <span class="detection-count">${count}</span>
                    </li>
                `;
            }
            html += '</ul>';

            container.innerHTML = html;
        }

        // å¯åŠ¨æ£€æµ‹
        async function startDetection() {
            try {
                const response = await fetch('/start', {
                    method: 'POST'
                });

                const result = await response.json();

                if (result.status === 'success' || result.status === 'already_running') {
                    isRunning = true;
                    startBtn.disabled = true;
                    stopBtn.disabled = false;
                    updateStatus('è¿è¡Œä¸­', 'running');

                    // è¿æ¥ WebSocket
                    if (!ws) {
                        connectWebSocket();
                    }

                    // å¼€å§‹æ›´æ–°ç»Ÿè®¡
                    startStatsUpdate();
                } else {
                    alert('å¯åŠ¨å¤±è´¥: ' + result.message);
                }
            } catch (error) {
                console.error('å¯åŠ¨æ£€æµ‹å¤±è´¥:', error);
                alert('å¯åŠ¨æ£€æµ‹å¤±è´¥');
            }
        }

        // åœæ­¢æ£€æµ‹
        async function stopDetection() {
            try {
                const response = await fetch('/stop', {
                    method: 'POST'
                });

                const result = await response.json();

                if (result.status === 'success' || result.status === 'not_running') {
                    isRunning = false;
                    startBtn.disabled = false;
                    stopBtn.disabled = true;
                    updateStatus('å·²åœæ­¢', 'stopped');

                    // å…³é—­ WebSocket
                    if (ws) {
                        ws.close();
                    }

                    // åœæ­¢æ›´æ–°ç»Ÿè®¡
                    stopStatsUpdate();
                }
            } catch (error) {
                console.error('åœæ­¢æ£€æµ‹å¤±è´¥:', error);
            }
        }

        // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
        async function updateStats() {
            try {
                const response = await fetch('/stats');
                const stats = await response.json();

                document.getElementById('runtime').textContent = `${stats.runtime_seconds} ç§’`;
                document.getElementById('total-frames').textContent = stats.frame_count;
                document.getElementById('total-detections').textContent = stats.total_detections;
                document.getElementById('avg-detections').textContent = stats.avg_detections_per_frame.toFixed(2);

                // å¦‚æœçŠ¶æ€æ”¹å˜ï¼Œæ›´æ–°æŒ‰é’®
                if (stats.is_running !== isRunning) {
                    isRunning = stats.is_running;
                    startBtn.disabled = isRunning;
                    stopBtn.disabled = !isRunning;
                    updateStatus(isRunning ? 'è¿è¡Œä¸­' : 'å·²åœæ­¢', isRunning ? 'running' : 'stopped');
                }
            } catch (error) {
                console.error('è·å–ç»Ÿè®¡å¤±è´¥:', error);
            }
        }

        // å¼€å§‹æ›´æ–°ç»Ÿè®¡
        function startStatsUpdate() {
            if (statsInterval) {
                clearInterval(statsInterval);
            }
            statsInterval = setInterval(updateStats, 1000);
            updateStats(); // ç«‹å³æ›´æ–°ä¸€æ¬¡
        }

        // åœæ­¢æ›´æ–°ç»Ÿè®¡
        function stopStatsUpdate() {
            if (statsInterval) {
                clearInterval(statsInterval);
                statsInterval = null;
            }
        }

        // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
        function updateStatus(text, className) {
            const statusDisplay = document.getElementById('status-display');
            statusDisplay.textContent = `çŠ¶æ€: ${text}`;
            statusDisplay.className = className;
        }

        // æ¨¡å‹åˆ‡æ¢åŠŸèƒ½
        async function switchModel(modelType) {
            try {
                const response = await fetch('/switch_model', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ model_type: modelType })
                });

                const result = await response.json();

                if (result.status === 'success') {
                    // æ›´æ–°æŒ‰é’®çŠ¶æ€
                    const detectionBtn = document.getElementById('detection-btn');
                    const emotionBtn = document.getElementById('emotion-btn');
                    const titleElement = document.getElementById('system-title');

                    if (modelType === 'emotion') {
                        detectionBtn.className = 'btn btn-secondary model-btn';
                        emotionBtn.className = 'btn btn-primary model-btn active';
                        titleElement.textContent = 'ğŸ˜Š äººè„¸æƒ…æ„Ÿè¯†åˆ«å®æ—¶æ£€æµ‹ç³»ç»Ÿ';
                    } else {
                        detectionBtn.className = 'btn btn-primary model-btn active';
                        emotionBtn.className = 'btn btn-secondary model-btn';
                        titleElement.textContent = 'ğŸ¯ YOLO USB æ‘„åƒå¤´å®æ—¶æ£€æµ‹ç³»ç»Ÿ';
                    }

                    // æ˜¾ç¤ºåˆ‡æ¢æˆåŠŸæ¶ˆæ¯
                    console.log(result.message || 'æ¨¡å‹åˆ‡æ¢æˆåŠŸ');

                    // å¦‚æœæ˜¾ç¤ºæ¶ˆæ¯æç¤º
                    if (result.auto_started) {
                        console.log('æ£€æµ‹å·²è‡ªåŠ¨é‡å¯');
                    }
                } else {
                    alert('æ¨¡å‹åˆ‡æ¢å¤±è´¥: ' + (result.message || 'æœªçŸ¥é”™è¯¯'));
                }
            } catch (error) {
                console.error('æ¨¡å‹åˆ‡æ¢å¤±è´¥:', error);
                alert('æ¨¡å‹åˆ‡æ¢å¤±è´¥');
            }
        }

        // åº”ç”¨é…ç½®
        async function applySettings() {
            const config = {
                display_confidence_threshold: parseFloat(confidenceSlider.value),
                nms_threshold: parseFloat(nmsSlider.value),
                max_fps: parseInt(fpsSlider.value)
            };

            try {
                const response = await fetch('/config', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(config)
                });

                const result = await response.json();
                if (result.status === 'success') {
                    alert('è®¾ç½®å·²åº”ç”¨');
                }
            } catch (error) {
                console.error('åº”ç”¨è®¾ç½®å¤±è´¥:', error);
                alert('åº”ç”¨è®¾ç½®å¤±è´¥');
            }
        }

        // äº‹ä»¶ç›‘å¬å™¨
        startBtn.addEventListener('click', startDetection);
        stopBtn.addEventListener('click', stopDetection);
        refreshBtn.addEventListener('click', () => {
            location.reload();
        });
        applySettingsBtn.addEventListener('click', applySettings);

        // æ»‘å—å€¼æ›´æ–°
        confidenceSlider.addEventListener('input', (e) => {
            document.getElementById('confidence-value').textContent = parseFloat(e.target.value).toFixed(2);
        });

        nmsSlider.addEventListener('input', (e) => {
            document.getElementById('nms-value').textContent = parseFloat(e.target.value).toFixed(2);
        });

        fpsSlider.addEventListener('input', (e) => {
            document.getElementById('fps-value').textContent = e.target.value;
        });

        // é¡µé¢åŠ è½½æ—¶è·å–é…ç½®
        async function loadConfig() {
            try {
                const response = await fetch('/config');
                if (response.ok) {
                    const config = await response.json();

                    confidenceSlider.value = config.display_confidence_threshold;
                    nmsSlider.value = config.nms_threshold;
                    fpsSlider.value = config.max_fps;

                    document.getElementById('confidence-value').textContent = config.display_confidence_threshold.toFixed(2);
                    document.getElementById('nms-value').textContent = config.nms_threshold.toFixed(2);
                    document.getElementById('fps-value').textContent = config.max_fps;
                } else {
                    console.warn('é…ç½®ç«¯ç‚¹ä¸å¯ç”¨ï¼Œä½¿ç”¨é»˜è®¤å€¼');
                }
            } catch (error) {
                console.error('åŠ è½½é…ç½®å¤±è´¥:', error);
            }
        }

        // åˆå§‹åŒ–
        window.addEventListener('load', () => {
            loadConfig();
            updateStats();
        });

        // é¡µé¢å¸è½½æ—¶æ¸…ç†
        window.addEventListener('beforeunload', () => {
            if (ws) {
                ws.close();
            }
            if (statsInterval) {
                clearInterval(statsInterval);
            }
        });
    </script>
</body>
</html>